diff -urN libguestfs-1.44.1.orig/generator/actions_core.ml libguestfs-1.44.1.mod/generator/actions_core.ml
--- libguestfs-1.44.1.orig/generator/actions_core.ml	2021-04-03 06:24:38.048065697 -0400
+++ libguestfs-1.44.1.mod/generator/actions_core.ml	2021-07-18 19:40:04.092726952 -0400
@@ -210,7 +210,7 @@
 
   { defaults with
     name = "add_drive"; added = (0, 0, 3);
-    style = RErr, [String (PlainString, "filename")], [OBool "readonly"; OString "format"; OString "iface"; OString "name"; OString "label"; OString "protocol"; OStringList "server"; OString "username"; OString "secret"; OString "cachemode"; OString "discard"; OBool "copyonread"; OInt "blocksize"];
+    style = RErr, [String (PlainString, "filename")], [OBool "readonly"; OString "format"; OString "iface"; OString "name"; OString "label"; OString "protocol"; OStringList "server"; OString "username"; OString "secret"; OString "cachemode"; OString "discard"; OBool "copyonread"; OInt "blocksize"; OString "secobject"];
     once_had_no_optargs = true;
     blocking = false;
     fish_alias = ["add"];
@@ -479,6 +479,13 @@
 Only a subset of the backends support this parameter (currently only the
 libvirt and direct backends do).
 
+=item C<secobject>
+
+The object that describes the encryption key if the drive is encrypted.
+e.g. secobject:secret,id=sec0,data=backing where id is the name of the 
+encryption object, data is the encryption key in plain text.
+
+
 =back" };
 
   { defaults with
diff -urN libguestfs-1.44.1.orig/lib/drives.c libguestfs-1.44.1.mod/lib/drives.c
--- libguestfs-1.44.1.orig/lib/drives.c	2020-03-06 14:31:08.168077968 -0500
+++ libguestfs-1.44.1.mod/lib/drives.c	2021-07-18 22:10:38.747649103 -0400
@@ -59,6 +59,7 @@
   enum discard discard;
   bool copyonread;
   int blocksize;
+  char *secobject;
 };
 
 COMPILE_REGEXP (re_hostname_port, "(.*):(\\d+)$", 0)
@@ -116,6 +117,7 @@
   drv->discard = data->discard;
   drv->copyonread = data->copyonread;
   drv->blocksize = data->blocksize;
+  drv->secobject = data->secobject ? safe_strdup (g, data->secobject) : NULL;
 
   if (data->readonly) {
     if (create_overlay (g, drv) == -1) {
@@ -639,6 +641,37 @@
   return 0;
 }
 
+/**
+ * The object value must be in the format secret,id=sec0,data=backing
+ */
+static int
+valid_secobject (guestfs_h *g, char *secobject)
+{
+  /* Returns first token */
+  char *id;
+  char *data;
+  char *key;
+  char *seccopy = safe_strdup(g, secobject);
+  char *token = strtok(seccopy, ",");
+
+  if (strncmp(token, "secret", strlen("secret")) != 0) {
+    return 0;
+  }
+
+  id = strtok(NULL, ",");
+  data = strtok(NULL, ",");
+
+  key = strtok(id, "=");
+  if (strncmp(key, "id", strlen("id")) != 0) {
+    return 0;
+  }
+  key = strtok(data, "=");
+  if (strncmp(key, "data", strlen("data")) != 0) {
+    return 0;
+  }
+  return 1;
+}
+
 static int
 parse_one_server (guestfs_h *g, const char *server, struct drive_server *ret)
 {
@@ -767,6 +800,8 @@
     ? optargs->secret : NULL;
   data.cachemode = optargs->bitmask & GUESTFS_ADD_DRIVE_OPTS_CACHEMODE_BITMASK
     ? optargs->cachemode : NULL;
+  data.secobject = optargs->bitmask & GUESTFS_ADD_DRIVE_OPTS_SECOBJECT_BITMASK
+    ? (char *) optargs->secobject : NULL;
 
   if (optargs->bitmask & GUESTFS_ADD_DRIVE_OPTS_DISCARD_BITMASK) {
     if (STREQ (optargs->discard, "disable"))
@@ -827,6 +862,12 @@
     return -1;
   }
 
+  if (data.secobject && !valid_secobject (g, data.secobject)) {
+    error (g, _("%s parameter is invalid"), "object");
+    free_drive_servers (data.servers, data.nr_servers);
+    return -1;
+  }
+
   if (STREQ (protocol, "file")) {
     if (data.servers != NULL) {
       error (g, _("you cannot specify a server with file-backed disks"));
@@ -848,11 +889,24 @@
       /* We have to check for the existence of the file since that's
        * required by the API.
        */
-      if (access (filename, R_OK) == -1) {
-        perrorf (g, "%s", filename);
-        return -1;
+      char *fptr;
+      char *tmp;
+      char *filesubstr;
+
+      if ((fptr = strstr(filename, "file.filename=")) == NULL) {
+        if (access (filename, R_OK) == -1) {
+          perrorf (g, "%s", filename);
+          return -1;
+        }
+      } else {
+        fptr += strlen("file.filename=");
+        filesubstr = safe_strdup (g, fptr);
+	tmp = strtok(filesubstr, ",");
+        if (access (tmp, R_OK) == -1) {
+          perrorf (g, "%s", filename);
+          return -1;
+        }
       }
-
       drv = create_drive_file (g, &data);
     }
   }
diff -urN libguestfs-1.44.1.orig/lib/guestfs-internal.h libguestfs-1.44.1.mod/lib/guestfs-internal.h
--- libguestfs-1.44.1.orig/lib/guestfs-internal.h	2021-04-03 06:20:10.305684996 -0400
+++ libguestfs-1.44.1.mod/lib/guestfs-internal.h	2021-07-18 22:10:38.730649422 -0400
@@ -272,6 +272,7 @@
   enum discard discard;
   bool copyonread;
   int blocksize;
+  char *secobject;
 };
 
 /* Extra hv parameters (from guestfs_config). */
diff -urN libguestfs-1.44.1.orig/lib/launch-direct.c libguestfs-1.44.1.mod/lib/launch-direct.c
--- libguestfs-1.44.1.orig/lib/launch-direct.c	2020-03-06 14:31:08.171077925 -0500
+++ libguestfs-1.44.1.mod/lib/launch-direct.c	2021-07-18 22:10:38.712649760 -0400
@@ -202,10 +202,21 @@
 {
   if (!drv->overlay) {
     CLEANUP_FREE char *file = NULL;
+    CLEANUP_FREE char *token = NULL;
 
     /* file= parameter. */
     file = guestfs_int_drive_source_qemu_param (g, &drv->src);
-    append_list_format ("file=%s", file);
+    if (drv->secobject && strncmp(drv->secobject, "secret", strlen("secret")) == 0) {
+      /* get the first token */
+      token = strtok(file, ",");
+      /* walk through other tokens */
+      while ( token != NULL ) {
+        append_list(token);
+        token = strtok(NULL, ",");
+      }
+    } else {
+      append_list_format ("file=%s", file);
+    }
 
     if (drv->readonly)
       append_list ("snapshot=on");
@@ -606,6 +617,11 @@
       append_list ("rng=rng0");
     } end_list ();
   }
+  start_list ("--object") {
+    append_list ("secret");
+    append_list ("id=sec0");
+    append_list ("data=backing");
+  } end_list ();
 
   /* Create the virtio-scsi bus. */
   start_list ("-device") {
diff -urN libguestfs-1.44.1.orig/lib/qemu.c libguestfs-1.44.1.mod/lib/qemu.c
--- libguestfs-1.44.1.orig/lib/qemu.c	2021-04-03 06:20:33.492458904 -0400
+++ libguestfs-1.44.1.mod/lib/qemu.c	2021-07-18 22:10:38.688650210 -0400
@@ -817,13 +817,16 @@
      * As a side-effect this deals with paths that contain ':' since
      * qemu will not process the ':' if the path begins with '/'.
      */
-    path = realpath (src->u.path, NULL);
-    if (path == NULL) {
-      perrorf (g, _("realpath: could not convert ‘%s’ to absolute path"),
-               src->u.path);
-      return NULL;
-    }
-    return path;
+    if (strstr (src->u.path, "secret") == NULL) {
+      path = realpath (src->u.path, NULL);
+      if (path == NULL) {
+        perrorf (g, _("realpath: could not convert ‘%s’ to absolute path"),
+                 src->u.path);
+        return NULL;
+      }
+      return path;
+    } else
+      return safe_strdup (g, src->u.path);
 
   case drive_protocol_ftp:
     return make_uri (g, "ftp", src->username, src->secret,
diff -urN libguestfs-1.44.1.orig/README libguestfs-1.44.1.mod/README
--- libguestfs-1.44.1.orig/README	2020-03-06 14:31:08.077079274 -0500
+++ libguestfs-1.44.1.mod/README	2021-07-18 22:10:38.666650623 -0400
@@ -20,3 +20,36 @@
 distributed under the GPLv2+.  Please see the files COPYING and
 COPYING.LIB for full license information.  The examples are under a
 very liberal license.
+
+####################################################################
+To build libguestfs from this repository
+
+$ https://github.com/MuralidharB/libguestfs-1.44.1.git
+$ cd libguestfs-1.44.1
+$ export GO111MODULE=auto # Need this as the golang working directory is not a module, hence this env should be set to 'auto' instead of 'on'.
+$ sudo yum install automake
+$ aclocal
+$ ./autogen.sh # you may need to run it again if the first invocation fails
+# autogen.sh may overwrite some of our modifications because these are autogenerated files
+# We have yet to figure out how to make changes to original files. Please checkout the 
+# files again from the repo. These files are:
+   1. include/guestfs.h
+   2. fish/run-2.c
+   3. lib/actions-2.c
+   4. golang/src/libguestfs.org/guestfs/guestfs.go
+   5. python/guestfs.py
+   6. python/actions-2.c
+
+$ make
+
+
+To verify that the build is successful and the new binary supports encrypted qcow2 images, follow these steps:
+$ dd if=/dev/urandom of=/tmp/base bs=1M count=1024
+$ qemu-img convert -p --object secret,id=sec0,data=backing --object secret,id=sec2,data=backing --image-opts driver=raw,file.filename=/tmp/base -O qcow2 -o encrypt.format=luks,encrypt.key-secret=sec2 /tmp/base.qcow2
+$ qemu-img create -f qcow2 --object secret,id=sec0,data=backing -b 'json:{ "encrypt.key-secret": "sec0", "driver": "qcow2", "file": { "driver": "file", "filename": "/tmp/base.qcow2" }}' -o encrypt.format=luks,encrypt.key-secret=sec0 /tmp/overlay.qcow2 1G
+
+$ ./run guestfish
+<fs> add driver=qcow2,file.filename=/tmp/overlay.qcow2,encrypt.key-secret=sec0 secobject:secret,id=sec0,data=backing
+<fs> run   
+
+The appliance should successfully boot and provide with prompt
